<!DOCTYPE html>
<html lang="zh-cn">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>lt_offer_14-剪绳子 - 白夜的zippo打火机</title>
<meta name="generator" content="Hugo 0.91.1" />
<link href="http://zippomou.github.io//index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="http://zippomou.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lt_offer_14/">
<link rel="stylesheet" href="http://zippomou.github.io/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="http://zippomou.github.io/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script src="http://zippomou.github.io/js/bundle.js"></script><style>
:root {}
</style>
<meta property="og:title" content="lt_offer_14-剪绳子" />
<meta property="og:description" content="题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]&hellip;k[m-1] 。请问 k[0]k[1]&hellip;*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
解题报告 先使用记忆化搜索 定义dfs(x)为将x至少拆为2部分的乘积的最大值，注意在转化时，对于x&gt;x， x不是一定要拆开，所以dfs(x)=max(dfs(x)*(x-x), (x-x)*x)
func cuttingRope(n int) int { var dfs func(x int) int cache:=make(map[int]int) dfs = func (x int) int { if x==1 { return 1 } if v,ok:=cache[x];ok { return v } ans:=0 for i:=1;i&lt;x;i&#43;&#43; { ans = maxInt(ans, dfs(x-i)*i, (x-i)*i) } cache[x]=ans return ans } return dfs(n) } func maxInt(nums ...int) int { r:=-1 for i:=range nums { if r&lt;nums[i] { r=nums[i] } } return r } 将记忆化搜索转化成动态规划,转化关系dp(x)=max(dp(x)*(x-x), (x-x)*x)， x依赖于比它小的x，所以从小到达遍历" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://zippomou.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lt_offer_14/" /><meta property="article:section" content="数据结构与算法" />
<meta property="article:published_time" content="2022-04-13T12:28:05+08:00" />
<meta property="article:modified_time" content="2022-04-13T12:28:05+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="lt_offer_14-剪绳子"/>
<meta name="twitter:description" content="题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]&hellip;k[m-1] 。请问 k[0]k[1]&hellip;*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
解题报告 先使用记忆化搜索 定义dfs(x)为将x至少拆为2部分的乘积的最大值，注意在转化时，对于x&gt;x， x不是一定要拆开，所以dfs(x)=max(dfs(x)*(x-x), (x-x)*x)
func cuttingRope(n int) int { var dfs func(x int) int cache:=make(map[int]int) dfs = func (x int) int { if x==1 { return 1 } if v,ok:=cache[x];ok { return v } ans:=0 for i:=1;i&lt;x;i&#43;&#43; { ans = maxInt(ans, dfs(x-i)*i, (x-i)*i) } cache[x]=ans return ans } return dfs(n) } func maxInt(nums ...int) int { r:=-1 for i:=range nums { if r&lt;nums[i] { r=nums[i] } } return r } 将记忆化搜索转化成动态规划,转化关系dp(x)=max(dp(x)*(x-x), (x-x)*x)， x依赖于比它小的x，所以从小到达遍历"/>
<meta itemprop="name" content="lt_offer_14-剪绳子">
<meta itemprop="description" content="题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]&hellip;k[m-1] 。请问 k[0]k[1]&hellip;*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
解题报告 先使用记忆化搜索 定义dfs(x)为将x至少拆为2部分的乘积的最大值，注意在转化时，对于x&gt;x， x不是一定要拆开，所以dfs(x)=max(dfs(x)*(x-x), (x-x)*x)
func cuttingRope(n int) int { var dfs func(x int) int cache:=make(map[int]int) dfs = func (x int) int { if x==1 { return 1 } if v,ok:=cache[x];ok { return v } ans:=0 for i:=1;i&lt;x;i&#43;&#43; { ans = maxInt(ans, dfs(x-i)*i, (x-i)*i) } cache[x]=ans return ans } return dfs(n) } func maxInt(nums ...int) int { r:=-1 for i:=range nums { if r&lt;nums[i] { r=nums[i] } } return r } 将记忆化搜索转化成动态规划,转化关系dp(x)=max(dp(x)*(x-x), (x-x)*x)， x依赖于比它小的x，所以从小到达遍历"><meta itemprop="datePublished" content="2022-04-13T12:28:05+08:00" />
<meta itemprop="dateModified" content="2022-04-13T12:28:05+08:00" />
<meta itemprop="wordCount" content="124">
<meta itemprop="keywords" content="" /></head>
<body><div class="container"><header>
<h1>白夜的zippo打火机</h1>
</header>

<div class="content-container">
<main><h1>lt_offer_14-剪绳子</h1>
<h2 id="题目httpsleetcode-cncomproblemsjian-sheng-zi-lcof"><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">题目</a></h2>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]&hellip;k[m-1] 。请问 k[0]<em>k[1]</em>&hellip;*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h2 id="解题报告">解题报告</h2>
<p>先使用记忆化搜索
定义dfs(x)为将x至少拆为2部分的乘积的最大值，注意在转化时，对于x&gt;x， x不是一定要拆开，所以dfs(x)=max(dfs(x)*(x-x), (x-x)*x)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">cuttingRope</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">dfs</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">cache</span><span style="color:#f92672">:=</span>make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">dfs</span> = <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">==</span><span style="color:#ae81ff">1</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
		}
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>,<span style="color:#a6e22e">ok</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">cache</span>[<span style="color:#a6e22e">x</span>];<span style="color:#a6e22e">ok</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>
		}
		<span style="color:#a6e22e">ans</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">1</span>;<span style="color:#a6e22e">i</span>&lt;<span style="color:#a6e22e">x</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
			<span style="color:#a6e22e">ans</span> = <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">ans</span>, <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">x</span><span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>)<span style="color:#f92672">*</span><span style="color:#a6e22e">i</span>, (<span style="color:#a6e22e">x</span><span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>)<span style="color:#f92672">*</span><span style="color:#a6e22e">i</span>)
		}
		<span style="color:#a6e22e">cache</span>[<span style="color:#a6e22e">x</span>]=<span style="color:#a6e22e">ans</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ans</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">n</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">nums</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">r</span><span style="color:#f92672">:=-</span><span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>&lt;<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] {
			<span style="color:#a6e22e">r</span>=<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>]
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span>
}
</code></pre></div><p>将记忆化搜索转化成动态规划,转化关系dp(x)=max(dp(x)*(x-x), (x-x)*x)， x依赖于比它小的x，所以从小到达遍历</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">cuttingRope</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">fn</span><span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">n</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">fn</span>[<span style="color:#ae81ff">1</span>]=<span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">2</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">&lt;=</span><span style="color:#a6e22e">n</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">1</span>;<span style="color:#a6e22e">j</span>&lt;<span style="color:#a6e22e">i</span>;<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#a6e22e">fn</span>[<span style="color:#a6e22e">i</span>]=<span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">fn</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">fn</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#a6e22e">j</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">j</span>, (<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#a6e22e">j</span>)<span style="color:#f92672">*</span><span style="color:#a6e22e">j</span>)
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fn</span>[<span style="color:#a6e22e">n</span>]
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">nums</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">r</span><span style="color:#f92672">:=-</span><span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>&lt;<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] {
			<span style="color:#a6e22e">r</span>=<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>]
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span>
}
</code></pre></div><div class="edit-meta">
Last updated on 13 Apr 2022


<br>
Published on 13 Apr 2022
<br></div><nav class="pagination"><a class="nav nav-prev" href="http://zippomou.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法s"><i class="fas fa-arrow-left" aria-hidden="true"></i>&nbsp;Prev - 数据结构与算法s</a>

</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main>
<div class="sidebar">

<div class="sidebar-footer"></div>
</div>

</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
